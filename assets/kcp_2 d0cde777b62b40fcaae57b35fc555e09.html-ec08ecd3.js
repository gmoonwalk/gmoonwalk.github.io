import{_ as p,r as t,o as c,c as r,a as s,b as a,e as o,f as e}from"./app-60342b30.js";const l="/assets/kcp2-ca0f3bc5.png",i={},k=e(`<h1 id="kcp解读-基础消息收发" tabindex="-1"><a class="header-anchor" href="#kcp解读-基础消息收发" aria-hidden="true">#</a> KCP解读：基础消息收发</h1><p>接下来会涉及源码解读，这里以C#版本为基础讲解。</p><blockquote><p>kcp已经被port到很多语言和平台，它们都是C语言版本的移植，正常来说为了移植容易，保持一致性。方法、变量命名是一样的，区别不大。</p></blockquote><h2 id="segment" tabindex="-1"><a class="header-anchor" href="#segment" aria-hidden="true">#</a> Segment</h2><p>应用层发送的数据可能是一段文本、编码格式如protobuf、音频、视频，本质上它们都是二进制数据(一般是bytes数组)，我们叫它<strong>原始数据</strong>。</p><p>原始数据输入给kcp后，kcp对数据进行封装：增加消息头；超长数据进行分段等，封装后的数据叫做<strong>Segment</strong>。有一些不同的叫法，数据段、数据包、网络包等等，为了防止歧义，以下统一叫做<strong>数据包或简称包</strong>。数据包有包头和包体，包体就是原始数据。</p><h3 id="包头" tabindex="-1"><a class="header-anchor" href="#包头" aria-hidden="true">#</a> 包头</h3><div class="language-csharp line-numbers-mode" data-ext="cs"><pre class="language-csharp"><code><span class="token operator">|</span><span class="token operator">&lt;</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span> <span class="token number">4</span> bytes <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">&gt;</span><span class="token operator">|</span>
<span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span>
<span class="token operator">|</span>               conv                <span class="token operator">|</span> conv：Conversation<span class="token punctuation">,</span> 会话序号，用于标识收发数据包是否一致
<span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span> cmd<span class="token punctuation">:</span> command，用于标识指令，例如：push，ack等
<span class="token operator">|</span>  cmd   <span class="token operator">|</span>  frg   <span class="token operator">|</span>       wnd       <span class="token operator">|</span> frg<span class="token punctuation">:</span> Fragment<span class="token punctuation">,</span> 分段序号，序号从大到小
<span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span> wnd<span class="token punctuation">:</span> 接收窗口大小
<span class="token operator">|</span>                ts                 <span class="token operator">|</span> ts<span class="token punctuation">:</span> 发送的时间戳
<span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span>
<span class="token operator">|</span>                sn                 <span class="token operator">|</span> sn<span class="token punctuation">:</span> Segment序号
<span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span>
<span class="token operator">|</span>                una                <span class="token operator">|</span> una<span class="token punctuation">:</span> Unacknowledged<span class="token punctuation">,</span> 当前未收到的序号，即代表这个序号之前的包均收到
<span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span>      
<span class="token operator">|</span>                len                <span class="token operator">|</span> len<span class="token punctuation">:</span> data数据的长度
<span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里先了解每个字段的含义，后续结合源码加深理解。</p><h2 id="tcp的确认应答机制" tabindex="-1"><a class="header-anchor" href="#tcp的确认应答机制" aria-hidden="true">#</a> TCP的确认应答机制</h2>`,10),d={href:"https://xiaolincoding.com/network/3_tcp/tcp_feature.html#%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6",target:"_blank",rel:"noopener noreferrer"},u=e('<p>TCP 实现可靠传输的方式之一，是通过序列号与确认应答。</p><p>在 TCP 中，当发送端的数据到达接收主机时，接收端主机会返回一个确认应答消息，表示已收到消息。</p><figure><img src="'+l+'" alt="kcp2.png" tabindex="0" loading="lazy"><figcaption>kcp2.png</figcaption></figure><p>但在错综复杂的网络，并不一定能如上图那么顺利能正常的数据传输，万一数据在传输过程中丢失了呢？</p><p>所以 TCP 针对数据包丢失的情况，会用<strong>重传机制</strong>解决。</p><h3 id="超时重传" tabindex="-1"><a class="header-anchor" href="#超时重传" aria-hidden="true">#</a> <strong>超时重传</strong></h3><p>重传机制的其中一个方式，就是在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 <code>ACK</code> 确认应答报文，就会重发该数据，也就是我们常说的<strong>超时重传</strong>。</p><p>TCP 会在以下两种情况发生超时重传：</p><ul><li>数据包丢失</li><li>确认应答丢失</li></ul><blockquote><p>超时时间应该设置为多少呢？</p></blockquote><p>我们先来了解一下什么是 <code>RTT</code>（Round-Trip Time 往返时延），从下图我们就可以知道：</p>',11),m=s("img",{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/计算机网络/TCP-可靠特性/6.jpg?",alt:"https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/计算机网络/TCP-可靠特性/6.jpg?",tabindex:"0",loading:"lazy"},null,-1),_={href:"https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/6.jpg",target:"_blank",rel:"noopener noreferrer"},g=s("p",null,[s("code",null,"RTT"),a(" 指的是"),s("strong",null,"数据发送时刻到接收到确认的时刻的差值"),a("，也就是包的往返时间。")],-1),h=s("p",null,[a("超时重传时间是以 "),s("code",null,"RTO"),a(" （Retransmission Timeout 超时重传时间）表示。")],-1),v=s("p",null,[a("假设在重传的情况下，超时时间 "),s("code",null,"RTO"),a(" 「较长或较短」时，会发生什么事情呢？")],-1),b=s("img",{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/计算机网络/TCP-可靠特性/7.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0",alt:"https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/计算机网络/TCP-可靠特性/7.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0",tabindex:"0",loading:"lazy"},null,-1),x={href:"https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/7.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0",target:"_blank",rel:"noopener noreferrer"},f=e("<p>上图中有两种超时时间不同的情况：</p><ul><li>当超时时间 <strong>RTO 较大</strong>时，重发就慢，丢了老半天才重发，没有效率，性能差；</li><li>当超时时间 <strong>RTO 较小</strong>时，会导致可能并没有丢就重发，于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。</li></ul><p>精确的测量超时时间 <code>RTO</code> 的值是非常重要的，这可让我们的重传机制更高效。</p><p>根据上述的两种情况，我们可以得知，<strong>超时重传时间 RTO 的值应该略大于报文往返 RTT 的值</strong>。</p>",4),C=s("img",{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/计算机网络/TCP-可靠特性/8.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0",alt:"https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/计算机网络/TCP-可靠特性/8.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0",tabindex:"0",loading:"lazy"},null,-1),y={href:"https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/8.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0",target:"_blank",rel:"noopener noreferrer"},w=e(`<p>至此，可能大家觉得超时重传时间 <code>RTO</code> 的值计算，也不是很复杂嘛。</p><p>好像就是在发送端发包时记下 <code>t0</code> ，然后接收端再把这个 <code>ack</code> 回来时再记一个 <code>t1</code>，于是 <code>RTT = t1 – t0</code>。没那么简单，<strong>这只是一个采样，不能代表普遍情况</strong>。</p><p>实际上「报文往返 RTT 的值」是经常变化的，因为我们的网络也是时常变化的。也就因为「报文往返 RTT 的值」 是经常波动变化的，所以「超时重传时间 RTO 的值」应该是一个<strong>动态变化的值</strong>。</p><h2 id="kcp消息发送" tabindex="-1"><a class="header-anchor" href="#kcp消息发送" aria-hidden="true">#</a> KCP消息发送</h2><p>原始数据发送到kcp的<code>send</code>接口，kcp根据mss(最大报文长度)拆分成多个数据包，加入到消息发送队列<code>snd_queue</code></p><h3 id="flush方法" tabindex="-1"><a class="header-anchor" href="#flush方法" aria-hidden="true">#</a> flush方法</h3><p>消息发送逻辑都在这个方法里。</p><p>首先，将消息发送队列的包进行初始化，放置到发送缓冲区：</p><div class="language-csharp line-numbers-mode" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>snd_queue<span class="token punctuation">.</span><span class="token function">TryDequeue</span><span class="token punctuation">(</span><span class="token keyword">out</span> <span class="token class-name"><span class="token keyword">var</span></span> newseg<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    newseg<span class="token punctuation">.</span>conv <span class="token operator">=</span> conv<span class="token punctuation">;</span><span class="token comment">//频道号</span>
    newseg<span class="token punctuation">.</span>cmd <span class="token operator">=</span> IKCP_CMD_PUSH<span class="token punctuation">;</span><span class="token comment">//报文类型：数据报文</span>
    newseg<span class="token punctuation">.</span>wnd <span class="token operator">=</span> wnd_<span class="token punctuation">;</span><span class="token comment">//窗口大小</span>
    newseg<span class="token punctuation">.</span>ts <span class="token operator">=</span> current_<span class="token punctuation">;</span><span class="token comment">//发送时间戳</span>
    newseg<span class="token punctuation">.</span>sn <span class="token operator">=</span> snd_nxt<span class="token punctuation">;</span><span class="token comment">//发送编号</span>
    snd_nxt<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">//自增</span>
    newseg<span class="token punctuation">.</span>una <span class="token operator">=</span> rcv_nxt<span class="token punctuation">;</span><span class="token comment">//</span>
    newseg<span class="token punctuation">.</span>resendts <span class="token operator">=</span> current_<span class="token punctuation">;</span><span class="token comment">//重传的时间戳。超过当前时间重发这个包，发送时会继续修改，加rto</span>
    newseg<span class="token punctuation">.</span>rto <span class="token operator">=</span> rx_rto<span class="token punctuation">;</span><span class="token comment">//超时重传时间</span>
    newseg<span class="token punctuation">.</span>fastack <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//快速重传技术，每次发送都置零</span>
    newseg<span class="token punctuation">.</span>xmit <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//重传次数</span>
    <span class="token keyword">lock</span> <span class="token punctuation">(</span>snd_bufLock<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        snd_buf<span class="token punctuation">.</span><span class="token function">AddLast</span><span class="token punctuation">(</span>newseg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//加入到正在发送列表</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>snd_nxt是发送编号，值是下一个要发的数据包编号。una表示这个编号之前的包，接收端都收到了。xmit是重传次数，=0直接发送。</p><div class="language-csharp line-numbers-mode" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>segment<span class="token punctuation">.</span>xmit <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">//首次发送</span>
<span class="token punctuation">{</span>
    <span class="token comment">//新加入 snd_buf 中, 从未发送过的报文直接发送出去;</span>
    needsend <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    segment<span class="token punctuation">.</span>xmit<span class="token operator">++</span><span class="token punctuation">;</span>
    segment<span class="token punctuation">.</span>rto <span class="token operator">=</span> rx_rto<span class="token punctuation">;</span>
    segment<span class="token punctuation">.</span>resendts <span class="token operator">=</span> current_ <span class="token operator">+</span> rx_rto <span class="token operator">+</span> rtomin<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>resendts是超时时间戳，后面用于检查重发。最后，调用kcp回调<code>callbackHandle.Output</code> 给应用层进行数据发送，该回调中实现消息的发送即可。</p><h2 id="消息接收" tabindex="-1"><a class="header-anchor" href="#消息接收" aria-hidden="true">#</a> 消息接收</h2><p>应用层收到网络数据后，发送到kcp的<code>Input</code> 接口，在这里进行数据包解析。</p><p>假设接收到刚才发送过来的数据包：</p><ol><li>先解析包头，检查cmd字段发现是数据报文，进行数据报文的处理流程。</li><li><em><code>ikcp_ack_push</code></em> 将sn放入ack列表，稍后回复ACK报文给发送端，告知sn这个包已经收到。</li><li><code>Parse_data</code> 解析数据包，根据sn从小到大排序把数据包放入接收缓冲列表<code>rcv_buf</code> 。</li><li><code>Move_Rcv_buf_2_Rcv_queue</code> 遍历<code>rcv_buf</code> ，如果sn==<code>rcv_nxt</code> 待接收编号，那么把数据包放入待处理消息列表<code>rcv_queue</code></li><li>此时，<code>rcv_queue</code> 就是按顺序接收到的数据包列表，在kcp的<code>ikcp_recv</code> 类似的消息接收接口中，遍历该列表，重组得到原始数据。应用层调用该接口后，得到原始数据内容。</li></ol><h3 id="ack" tabindex="-1"><a class="header-anchor" href="#ack" aria-hidden="true">#</a> ACK</h3><p>ackowledged收到数据包的确认报文，接收方收到数据类型的报文后。在上面第2步，sn加入到ack列表，然后发送ack报文给发送方，ack包的sn赋值为该sn。</p><p>接收方收到ack报文后，更新<code>rtt</code>的值，通过<code>Parse_ack</code> 在<code>snd_buf</code>中删除sn这一条，至此一个消息就完整的发送完毕了。</p><h2 id="超时重发" tabindex="-1"><a class="header-anchor" href="#超时重发" aria-hidden="true">#</a> 超时重发</h2><p>在flush方法中，遍历消息发送缓存列表，如下条件的数据包进行重发。</p><div class="language-csharp line-numbers-mode" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">Itimediff</span><span class="token punctuation">(</span>current_<span class="token punctuation">,</span> segment<span class="token punctuation">.</span>resendts<span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">//超时重发</span>
<span class="token punctuation">{</span>
      <span class="token comment">//发送过的, 但是在 RTO 内未收到 ACK 的报文, 需要重传;</span>
      needsend <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
      segment<span class="token punctuation">.</span>xmit<span class="token operator">++</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,22);function T(E,P){const n=t("ExternalLinkIcon");return c(),r("div",null,[k,s("p",null,[a("推荐小林coding这个系列 "),s("a",d,[a("https://xiaolincoding.com/network/3_tcp/tcp_feature.html#重传机制"),o(n)])]),u,s("figure",null,[m,s("figcaption",null,[s("a",_,[a("https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/计算机网络/TCP-可靠特性/6.jpg"),o(n)]),a("?")])]),g,h,v,s("figure",null,[b,s("figcaption",null,[s("a",x,[a("https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/计算机网络/TCP-可靠特性/7.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0"),o(n)])])]),f,s("figure",null,[C,s("figcaption",null,[s("a",y,[a("https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/计算机网络/TCP-可靠特性/8.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0"),o(n)])])]),w])}const Y=p(i,[["render",T],["__file","kcp_2 d0cde777b62b40fcaae57b35fc555e09.html.vue"]]);export{Y as default};
