import{_ as o,r as i,o as s,c as r,a as e,b as a,e as c,f as n}from"./app-8b01e3ef.js";const p="/assets/Untitled-0100c276.png",d="/assets/kcp4-4360e901.png",l={},_=e("h1",{id:"kcp解读-重传机制",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#kcp解读-重传机制","aria-hidden":"true"},"#"),a(" KCP解读：重传机制")],-1),g={href:"https://xiaolincoding.com/network/3_tcp/tcp_feature.html#sack-%E6%96%B9%E6%B3%95",target:"_blank",rel:"noopener noreferrer"},h=n('<p>这里按照KCP的实现进行介绍，被发送方认为丢包有两种情况：</p><ol><li>数据包本身丢失</li><li>ack报文丢失</li></ol><figure><img src="'+p+'" alt="Untitled" tabindex="0" loading="lazy"><figcaption>Untitled</figcaption></figure><p>第一种情况下，数据包丢失，进行重传即可。第二种情况有所不同，主机B收到了所有数据包，但是ack报文丢包了，这两个包是不需要重发的，kcp通过ack+una的方式解决该问题。</p><h2 id="ack-una-选择性重传" tabindex="-1"><a class="header-anchor" href="#ack-una-选择性重传" aria-hidden="true">#</a> ACK+UNA 选择性重传</h2><p>kcp在包头中，增加了<code>una</code>字段（unacknowledged），意思是接收方正在等待接收的数据包编号。如图：</p><figure><img src="'+d+'" alt="kcp4.png" tabindex="0" loading="lazy"><figcaption>kcp4.png</figcaption></figure><p>接收方持有一个变量<code>rcv_nxt</code> ，是正在等待接收的数据包编号。当这个等待中的编号数据包收到，进行自增。把它发给对方后，对方就知道接收方实际收到的包了，那么中间ack报文丢失也不会有影响。</p><p>kcp就是通过ack和una两个数据，有效降低了丢包重发的数量。</p><h3 id="源码" tabindex="-1"><a class="header-anchor" href="#源码" aria-hidden="true">#</a> 源码</h3><p>包头的初始化代码：</p><p><code>newseg.una = rcv_nxt;</code></p><p>Input中收到数据包，对una的处理：</p><p><code>Parse_una(una);*//删除una之前的segment，una = rcv_nxt表示，对方una - 1已经收到，不用留着考虑重发了。*</code></p><h2 id="快速重传" tabindex="-1"><a class="header-anchor" href="#快速重传" aria-hidden="true">#</a> 快速重传</h2><p>TCP 还有另外一种<strong>快速重传（Fast Retransmit）机制</strong>，它<strong>不以时间为驱动，而是以数据驱动重传</strong>。</p><p>快速重传机制，是如何工作的呢？其实很简单，一图胜千言。</p>',17),f=e("img",{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/计算机网络/TCP-可靠特性/10.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0",alt:"https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/计算机网络/TCP-可靠特性/10.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0",tabindex:"0",loading:"lazy"},null,-1),k={href:"https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/10.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0",target:"_blank",rel:"noopener noreferrer"},u=n('<p>在上图，发送方发出了 1，2，3，4，5 份数据：</p><ul><li>第一份 Seq1 先送到了，于是就 Ack 回 2；</li><li>结果 Seq2 因为某些原因没收到，Seq3 到达了，于是还是 Ack 回 2；</li><li>后面的 Seq4 和 Seq5 都到了，但还是 Ack 回 2，因为 Seq2 还是没有收到；</li><li><strong>发送端收到了三个 Ack = 2 的确认，知道了 Seq2 还没有收到，就会在定时器过期之前，重传丢失的 Seq2。</strong></li><li>最后，收到了 Seq2，此时因为 Seq3，Seq4，Seq5 都收到了，于是 Ack 回 6 。</li></ul><p>所以，快速重传的工作方式是当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。</p><h3 id="源码-1" tabindex="-1"><a class="header-anchor" href="#源码-1" aria-hidden="true">#</a> 源码</h3><p>flush中判断fastack是否超过限制</p><p><code>else if (segment.fastack &gt;= resent)</code></p><p>Input中收到ack报文，记录本次的maxack，并在<code>Parse_fastack</code> 中对比发送缓冲区对fastack进行自增</p><p><code>maxack = sn;</code></p><p><code>Parse_fastack</code></p>',9);function m(x,C){const t=i("ExternalLinkIcon");return s(),r("div",null,[_,e("p",null,[a("关于TCP的机制可参考："),e("a",g,[a("https://xiaolincoding.com/network/3_tcp/tcp_feature.html#sack-方法"),c(t)])]),h,e("figure",null,[f,e("figcaption",null,[e("a",k,[a("https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/计算机网络/TCP-可靠特性/10.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0"),c(t)])])]),u])}const y=o(l,[["render",m],["__file","kcp_3 f17d06f7047b4c12bc78aa7f2953f2fe.html.vue"]]);export{y as default};
