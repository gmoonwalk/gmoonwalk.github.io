import{_ as a,r,o as l,c,a as e,b as t,e as n,f as o}from"./app-8b01e3ef.js";const s="/assets/kcp1-918f2de1.png",p={},C=e("h1",{id:"kcp技术原理",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#kcp技术原理","aria-hidden":"true"},"#"),t(" KCP技术原理")],-1),d=e("h2",{id:"kcp是什么",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#kcp是什么","aria-hidden":"true"},"#"),t(" KCP是什么")],-1),h={href:"https://github.com/skywind3000/kcp/tree/master",target:"_blank",rel:"noopener noreferrer"},P=o('<p>KCP是一个快速可靠协议，能以比 TCP浪费10%-20%的带宽的代价，换取平均延迟降低 30%-40%，且最大延迟降低三倍的传输效果。纯算法实现，并不负责底层协议（如UDP）的收发，需要使用者自己定义下层数据包的发送方式，并以 callback的方式提供给 KCP。</p><p>这里翻译一下，供参考</p><ol><li>KCP是一个ARQ协议：Automatic Repeat Query/Automatic repeat request，自动消息重发机制。</li><li>可靠协议，解决了丢包、乱序等问题。</li><li>可实现可靠UDP传输。不负责底层协议的收发，但是可以应用在几乎任何底层协议上，比如UDP。</li><li>比TCP快速，延迟低。</li></ol><h2 id="实现原理" tabindex="-1"><a class="header-anchor" href="#实现原理" aria-hidden="true">#</a> 实现原理</h2><p>网络模块是非常重要基础模块，了解实现原理和实现细节非常重要。这关系到后续出现问题能否解决，根据项目情况进一步定制，甚至技术选型是否能通过等重要问题。</p><p>KCP实现了一整套与TCP类似/功能对应的机制，它们有：</p><ul><li>超时重传</li><li>快速重传</li><li>滑动窗口</li><li>流量控制</li><li>拥塞控制</li></ul><h3 id="那我们为什么不直接用tcp呢-或者说它为什么比tcp快" tabindex="-1"><a class="header-anchor" href="#那我们为什么不直接用tcp呢-或者说它为什么比tcp快" aria-hidden="true">#</a> 那我们为什么不直接用TCP呢？或者说它为什么比TCP快？</h3><p>用作者的话说：TCP是为流量设计的（每秒内可以传输多少KB的数据），讲究的是充分利用带宽。而KCP是为流速设计的（单个数据包从一端发送到一端需要多少时间），以10%-20%带宽浪费的代价换取了比 TCP快30%-40%的传输速度。</p><p>因为TCP在传输层，用户程序不能进行更多的定制，基于UDP的KCP就可以通过调节与TCP类似的机制中的一些设定，实现了下面的技术特性，达到了提高流速的效果。</p><ul><li><strong>RTO翻倍vs不翻倍</strong>：TCP超时计算是RTOx2，这样连续丢三次包就变成RTOx8了，十分恐怖，而KCP启动快速模式后不x2，只是x1.5（实验证明1.5这个值相对比较好），提高了传输速度。</li><li><strong>选择性重传 vs 全部重传</strong>：TCP丢包时会全部重传从丢的那个包开始以后的数据，KCP是选择性重传，只重传真正丢失的数据包。</li><li><strong>快速重传</strong>：发送端发送了1,2,3,4,5几个包，然后收到远端的ACK: 1, 3, 4, 5，当收到ACK3时，KCP知道2被跳过1次，收到ACK4时，知道2被跳过了2次，此时可以认为2号丢失，不用等超时，直接重传2号包，大大改善了丢包时的传输速度。</li><li><strong>延迟ACK vs 非延迟ACK</strong> ：TCP为了充分利用带宽，延迟发送ACK（NODELAY都没用），这样超时计算会算出较大RTT时间，延长了丢包时的判断过程。KCP的ACK是否延迟发送可以调节。</li><li><strong>UNA vs ACK+UNA</strong> ：ARQ模型响应有两种，UNA（此编号前所有包已收到，如TCP）和ACK（该编号包已收到），光用 UNA会导致丢包时全部重传，光用 ACK又会导致 ACK丢失成本太高。KCP有单独ACK，且数据包和ACK包都带UNA信息，有效降低ACK丢失成本。</li><li><strong>非退让流控</strong>：KCP正常模式同TCP一样使用公平退让法则，即发送窗口大小由：发送缓存大小、接收端剩余接收缓存大小、丢包退让及慢启动这四要素决定。但传送及时性要求很高的小数据时，可选择通过配置跳过后两步，仅用前两项来控制发送频率。以牺牲部分公平性及带宽利用率之代价，换取了开着BT都能流畅传输的效果。</li></ul><h3 id="使用原理" tabindex="-1"><a class="header-anchor" href="#使用原理" aria-hidden="true">#</a> 使用原理</h3><p>以一个消息的收发为例：</p><ol><li>使用socket接口搭建udp底层通信，例如C#的Socket API。</li><li>发送数据前，调用kcp的send接口，发送到kcp，进行数据包拆分、封装。</li><li>设置kcp的output回调接口，数据包处理完成后，自动回调output接口。在这里通过socket发送到服务器</li><li>服务器部分运行流程与客户端相同，这里略过。消息处理完成后，服务器发包到客户端。</li><li>客户端的socket接口收到数据，调用kcp的input接口，kcp对数据包进行合并、解包。再通过回调接口，把真实的数据包返回给客户端进行逻辑处理。</li></ol><figure><img src="'+s+'" alt="kcp1.png" tabindex="0" loading="lazy"><figcaption>kcp1.png</figcaption></figure><p>接下来，结合大量现成的TCP资料的机制原理，一一讲解KCP这些技术特性。</p>',16);function K(u,k){const i=r("ExternalLinkIcon");return l(),c("div",null,[C,d,e("p",null,[t("开源地址： "),e("a",h,[t("https://github.com/skywind3000/kcp/tree/master"),n(i)])]),P])}const f=a(p,[["render",K],["__file","kcp_1 aeebf10f6c1a4f79bee7b8b67ae03ea6.html.vue"]]);export{f as default};
