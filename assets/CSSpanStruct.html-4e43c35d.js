const t=JSON.parse('{"key":"v-ce2b918a","path":"/csharp/CSSpanStruct.html","title":"C# Span<T> Struct","lang":"zh-CN","frontmatter":{"icon":"pen-to-square","date":"2023-06-14T00:00:00.000Z","category":["编程语言"],"tag":["c#"],"description":"C# Span&lt;T&gt; Struct 详情可以浏览 官方文档 这个结构，提供了一种类型安全且内存安全的方式来表示连续的任意内存区域。它是如何体现这些特性的呢？ Type-Safety：Span&lt;T&gt;是一个泛型结构体，这样它在编译期就强制的类型安全，否则会编译错误。你只能用T表示的类型来处理内存，不会出现类型错误导致的运行时错误。 边界检测：它会检测表示内存的边界，如果超出合法范围会抛出异常，但是不会发生异常内存访问导致的crash等问题。 Stack-only：只能在栈上使用，这就表示它不会产生内存泄露，一定会被合理释放。 支持切片：比如可以表示某数组的一部分内容，并且不需要进行内存复制，非常高效。 可以应用于大量的内存结构，适用性广泛。","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/csharp/CSSpanStruct.html"}],["meta",{"property":"og:site_name","content":"Moonwalk"}],["meta",{"property":"og:title","content":"C# Span<T> Struct"}],["meta",{"property":"og:description","content":"C# Span&lt;T&gt; Struct 详情可以浏览 官方文档 这个结构，提供了一种类型安全且内存安全的方式来表示连续的任意内存区域。它是如何体现这些特性的呢？ Type-Safety：Span&lt;T&gt;是一个泛型结构体，这样它在编译期就强制的类型安全，否则会编译错误。你只能用T表示的类型来处理内存，不会出现类型错误导致的运行时错误。 边界检测：它会检测表示内存的边界，如果超出合法范围会抛出异常，但是不会发生异常内存访问导致的crash等问题。 Stack-only：只能在栈上使用，这就表示它不会产生内存泄露，一定会被合理释放。 支持切片：比如可以表示某数组的一部分内容，并且不需要进行内存复制，非常高效。 可以应用于大量的内存结构，适用性广泛。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-06-14T06:28:41.000Z"}],["meta",{"property":"article:author","content":"Moonwalk"}],["meta",{"property":"article:tag","content":"c#"}],["meta",{"property":"article:published_time","content":"2023-06-14T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-06-14T06:28:41.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"C# Span<T> Struct\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-06-14T00:00:00.000Z\\",\\"dateModified\\":\\"2023-06-14T06:28:41.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Moonwalk\\",\\"url\\":\\"https://gmoonwalk.github.io\\"}]}"]]},"headers":[],"git":{"createdTime":1686712118000,"updatedTime":1686724121000,"contributors":[{"name":"zhouyue","email":"zhouyue@camel4u.com","commits":3}]},"readingTime":{"minutes":1.36,"words":407},"filePathRelative":"csharp/CSSpanStruct.md","localizedDate":"2023年6月14日","excerpt":"<h1> C# <code>Span&lt;T&gt;</code> Struct</h1>\\n<p>详情可以浏览 <a href=\\"https://learn.microsoft.com/en-us/dotnet/api/system.span-1?view=net-7.0\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">官方文档</a></p>\\n<p>这个结构，提供了一种类型安全且内存安全的方式来表示连续的任意内存区域。它是如何体现这些特性的呢？</p>\\n<ul>\\n<li>Type-Safety：<code>Span&lt;T&gt;</code>是一个泛型结构体，这样它在编译期就强制的类型安全，否则会编译错误。你只能用T表示的类型来处理内存，不会出现类型错误导致的运行时错误。</li>\\n<li>边界检测：它会检测表示内存的边界，如果超出合法范围会抛出异常，但是不会发生异常内存访问导致的crash等问题。</li>\\n<li>Stack-only：只能在栈上使用，这就表示它不会产生内存泄露，一定会被合理释放。</li>\\n<li>支持切片：比如可以表示某数组的一部分内容，并且不需要进行内存复制，非常高效。</li>\\n<li>可以应用于大量的内存结构，适用性广泛。</li>\\n</ul>","autoDesc":true}');export{t as data};
